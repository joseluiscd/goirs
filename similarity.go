// This file is part of GoIRS.
//
//    GoIRS is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    GoIRS is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with GoIRS.  If not, see <http://www.gnu.org/licenses/>.

package goirs

import (
	"encoding/xml"
	"os"
	"strconv"
)

//SimilarityMatrix is a matrix generated by ComputeSimilarityMatrix. As it is
//triangular, the lower index must be the first
type SimilarityMatrix struct {
	Matrix    map[int]map[int]float64
	Index     *FrequencyIndex
	DocLength int
}

//ComputeSimilarityMatrix computes a matrix which tells for each document pair
//how many tokens unique tokens do they have in common. It is supposed to be a
//triangular matrix, but values are repeated for the percentage computation.
func (ind *FrequencyIndex) ComputeSimilarityMatrix() SimilarityMatrix {
	result := make(map[int]map[int]float64)
	for x := 1; x < ind.NextDoc; x++ {
		result[x] = make(map[int]float64)
	}

	for _, docs := range ind.TokensCount {
		for doc1 := range docs {
			for doc2 := range docs {
				result[doc1][doc2] = result[doc1][doc2] + 1
			}
		}
	}

	return SimilarityMatrix{Matrix: result, Index: ind}
}

//Percentage normalizes the similarity matrix. Divides each row by the length of
//the document
func (sm SimilarityMatrix) Percentage() {
	for doc1, row := range sm.Matrix {
		f := float64(sm.Index.DocLength[doc1])
		for doc2 := range row {
			row[doc2] = row[doc2] / f
		}
		sm.Matrix[doc1] = row
	}
}

//Serialize exports a SimilarityMatrix to a file
func (sm SimilarityMatrix) Serialize(file string) {
	stream, err := os.Create(file)
	defer stream.Close()
	if err != nil {
		panic(err)
	}

	encoder := xml.NewEncoder(stream)
	err = encoder.Encode(sm)
	if err != nil {
		panic(err)
	}
}

//MarshalXML exports the matrix to XML
func (sm SimilarityMatrix) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	tokens := []xml.Token{start}

	for key, value := range sm.Matrix {
		t := xml.StartElement{Name: xml.Name{Local: "element"}, Attr: []xml.Attr{xml.Attr{Name: xml.Name{Local: "name"}, Value: sm.Index.DocNames[key]}}}
		tokens = append(tokens, t)
		for key2, value2 := range value {
			attr := []xml.Attr{xml.Attr{Name: xml.Name{Local: "name"}, Value: sm.Index.DocNames[key2]}}
			tokens = append(tokens,
				xml.StartElement{Name: xml.Name{Local: "similarity"}, Attr: attr},
				xml.CharData(strconv.FormatFloat(value2, 'g', -1, 64)),
				xml.EndElement{Name: xml.Name{Local: "similarity"}})

		}
		tokens = append(tokens, xml.EndElement{Name: xml.Name{Local: "element"}})
	}

	tokens = append(tokens, xml.EndElement{Name: start.Name})

	for _, t := range tokens {
		err := e.EncodeToken(t)
		if err != nil {
			return err
		}
	}

	// flush to ensure tokens are written
	err := e.Flush()
	if err != nil {
		return err
	}

	return nil
}
