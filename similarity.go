// This file is part of GoIRS.
//
//    GoIRS is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    GoIRS is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with GoIRS.  If not, see <http://www.gnu.org/licenses/>.

package goirs

import (
	"encoding/xml"
	"os"
	"strconv"
)

//SimilarityMatrix is a matrix generated by ComputeSimilarityMatrix. As it is
//triangular, the lower index must be the first
type SimilarityMatrix struct {
	Matrix map[int]map[int]float64
	Index  *FrequencyIndex
}

//ComputeSimilarityMatrix computes a matrix which tells for each document pair
//how many tokens unique tokens do they have in common. In order to not repeat
//the triangular matrix, lower document index comes first
func (ind *FrequencyIndex) ComputeSimilarityMatrix() SimilarityMatrix {
	result := make(map[int]map[int]float64)
	for x := 1; x < ind.NextDoc; x++ {
		result[x] = make(map[int]float64)
	}

	for _, docs := range ind.TokensCount {
		for doc1 := range docs {
			for doc2 := range docs {
				if doc1 < doc2 {
					result[doc1][doc2] = result[doc1][doc2] + 1
				}
			}
		}
	}

	return SimilarityMatrix{Matrix: result, Index: ind}
}

//Serialize exports a SimilarityMatrix to a file
func (sm SimilarityMatrix) Serialize(file string) {
	stream, err := os.Create(file)
	defer stream.Close()
	if err != nil {
		panic(err)
	}

	encoder := xml.NewEncoder(stream)
	err = encoder.Encode(sm)
	if err != nil {
		panic(err)
	}
}

//MarshalXML exports the matrix to XML
func (sm SimilarityMatrix) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	tokens := []xml.Token{start}

	for key, value := range sm.Matrix {
		t := xml.StartElement{Name: xml.Name{Local: "element"}, Attr: []xml.Attr{xml.Attr{Name: xml.Name{Local: "name"}, Value: sm.Index.DocNames[key]}}}
		tokens = append(tokens, t)
		for key2, value2 := range value {
			attr := []xml.Attr{xml.Attr{Name: xml.Name{Local: "name"}, Value: sm.Index.DocNames[key2]}}
			tokens = append(tokens,
				xml.StartElement{Name: xml.Name{Local: "similarity"}, Attr: attr},
				xml.CharData(strconv.FormatFloat(value2, 'g', -1, 64)),
				xml.EndElement{Name: xml.Name{Local: "similarity"}})

		}
		tokens = append(tokens, xml.EndElement{Name: xml.Name{Local: "element"}})
	}

	tokens = append(tokens, xml.EndElement{Name: start.Name})

	for _, t := range tokens {
		err := e.EncodeToken(t)
		if err != nil {
			return err
		}
	}

	// flush to ensure tokens are written
	err := e.Flush()
	if err != nil {
		return err
	}

	return nil
}
